\chapter{Algoritmi greedy}

\index{algoritmi greedy}

Un \key{algoritmo greedy} (avido, ingordo)
costruisce una soluzione del problema
scegliendo in ogni momento quella che è 
la migliore soluzione possibile.
In questo modo
non tornano mai indietro per modificare le proprie scelte,
ma costruisco direttamente la soluzione finale.
Per questa ragione gli algoritmi greedy sono solitamente
molto efficienti.

La difficoltà nel progettare gli algoritmi greedy
è quella di trovare una strategia greedy che garantisca 
di produrre sempre la soluzione ottimale del problema.

Una scelta ottima \textit{locale} deve sempre 
essere anche una scelta che garantisce un ottimo \textit{globale},
ma spesso è difficile dimostrare che un algoritmo greedy
funziona per ogni input.


\section{Problema delle monete}

Come primo esempio si consideri il problema 
in cui viene dato un insieme di monete e lo scopo
è quello di formare una somma $x$ usando le monete date.
I valori delle monete sono
$\texttt{coins}=\{c_1,c_2,\ldots,c_k\}$,
e ogni moneta può essere usata quante volte si vuole.
Qual è il mimino numero di monete necessario per ottenere la somma richiesta?

Per esempio, se le monete fossero degli euro (espressi in centesimi)
\[\{1,2,5,10,20,50,100,200\}\]
e $x=520$,
ci sarebbe bisogno di almeno quattro monete
e la soluzione ottima sarebbe
$200+200+100+20$, la cui somma è 520.

\subsubsection{Algoritmo greedy}

Un semplice algoritmo greedy che risolve il problema 
prevede di scegliere a ogni passo la più grande moneta possibile,
fino a che la somma delle monete non sia stata raggiunta.
Questo algoritmo funziona nel caso di esempio,
perchè inizialmente si sceglie due volte la moneta da 200,
poi una volta quella da 100 e infine una da 20.
Ma questo algoritmo funziona in ogni caso?
Si può verificare che se le monete sono quelle dell'insieme
proposto, l'algoritmo funziona sempre, cioè produce sempre 
una soluzione con il più piccolo numero possibile di monete.
La correttezza dell'algoritmo può essere dimostrata in questo modo:
ognuna delle monete 1, 5, 10, 50 e 100 appaiono al massimo 
una sola volta in una soluzione ottima,
perchè, se la soluzione contenesse due di tali monete,
queste potrebbero essere rimpiazzate da una sola moneta,
ottenendo così una soluzione migliore.
Per esempio, se la soluzione contenesse $5+5$,
le due monete dovrebbero essere rimpiazzate da una moneta da $10$.

Nello stesso modo, le monete 2 e 20 possono apparire al massimo due 
volte in una soluzione ottima, perchè la somma $2+2+2$ potrebbe essere
rimpiazzata dalla somma $5+1$ e la somma $20+20+20$ potrebbe essere rimpiazzata
dalla somma $50+10$.
Inoltre una soluzione ottima non può contenere le somme
$2+2+1$ o $20+20+10$ perchè potrebbero essere 
rimpiazzate rispettivamente dalle
monete $5$ e $50$.

Usando queste osservazioni 
si può mostrare che per ogni moneta di valore $x$,
non è possibile costruire una somma ottima $x$ o maggiore di $x$
usando solo monete di valore minore di $x$.
Per esempio, se $x=100$, la migliore somma ottima possibile
usando valori minori di 100 è $50+20+20+5+2+2=99$.
Quindi l'algoritmo greedy che seleziona ad ogni passo la più
grande moneta possibile produrrà sempre una soluzione ottima.

Questo esempio dimostra che può essere difficile
dimostrare la correttezza dell'algoritmo in tutte le situazioni,
anche se l'algoritmo in sé è semplice. 

\subsubsection{Caso generale}
Il caso generale di questo esempio può contenere monete
di qualsiasi valore e l'algoritmo greedy \emph{non} porta necessariamente
a una soluzione ottima.

Si può dimostrare che il procedimento greedy non sempre
funziona mostrando un controesempio in cui si ottiene un risultato non corretto.
Per questo problema trovare un controesempio è facile:
se le monete sono hanno valori $\{1,3,4\}$ e la somma richiesta è 6,
l'algoritmo greedy produrrebbe la soluzione 
$4+1+1$, mentre è evidente che la soluzione ottima è $3+3$.

Non si sa se il caso generale del problema delle monete
possa essere risolto da un qualsiasi algoritmo greedy\footnote{Comunque è possibile
\emph{verificare} in tempo polinomiale
se l'algoritmo greedy presentato in questo capitolo
funziona per un dato insieme di monete\cite{pea05}.}.

Comunque, come si vedrà nel Capitolo 7,
in alcuni casi il problema generale può essere risolto
in maniera efficiente usando la programmazione dinamica,
che fornisce sempre la risposta corretta.

\section{Scheduling}

Molti problemi di \emph{scheduling} possono essere risolti
usando degli algoritmi greedy.
Un problema classico è il seguente:
dati $n$ eventi con i propri tempi di inizio e di fine,
trovare una sequenza che contenga il numero maggiore possibile
di eventi non sovrapposti, cioè che non contenga una o più 
coppie di eventi la cui intersezione non sia vuota.
Si condiderino ad esempio i seguenti eventi:
\begin{center}
\begin{tabular}{lll}
evento & inizio & fine \\
\hline
$A$ & 1 & 3 \\
$B$ & 2 & 5 \\
$C$ & 3 & 9 \\
$D$ & 6 & 8 \\
\end{tabular}
\end{center}
In questo caso il numero massimo di eventi è due.
Per esempio si possono selezionare gli eventi $B$ e $D$
come segue:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw (2, 0) rectangle (6, -1);
    \draw[fill=lightgray] (4, -1.5) rectangle (10, -2.5);
    \draw (6, -3) rectangle (18, -4);
    \draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);
    \node at (2.5,-0.5) {$A$};
    \node at (4.5,-2) {$B$};
    \node at (6.5,-3.5) {$C$};
    \node at (12.5,-5) {$D$};
  \end{scope}
\end{tikzpicture}
\end{center}

Si possono inventare diversi algoritmi greedy per risolvere
questo problema, ma quale funzionerà con qualsiasi input?

\subsubsection*{Algoritmo 1}

La prima idea potrebbe essere quella di selezionare gli eventi
più \emph{corti} possibili, cioè quelli che durano di meno.
In questo esempio verrebbero selezionati i seguenti eventi:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw[fill=lightgray] (2, 0) rectangle (6, -1);
    \draw (4, -1.5) rectangle (10, -2.5);
    \draw (6, -3) rectangle (18, -4);
    \draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);
    \node at (2.5,-0.5) {$A$};
    \node at (4.5,-2) {$B$};
    \node at (6.5,-3.5) {$C$};
    \node at (12.5,-5) {$D$};
  \end{scope}
\end{tikzpicture}
\end{center}

Comunque questa strategia non porta sempre alla soluzione ottima.
Per esempio l'algoritmo fallisce con questi eventi:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw (1, 0) rectangle (7, -1);
    \draw[fill=lightgray] (6, -1.5) rectangle (9, -2.5);
    \draw (8, -3) rectangle (14, -4);
  \end{scope}
\end{tikzpicture}
\end{center}
Se viene selezionato l'evento più corto, risulta possibile selezionare solo quello,
dove la soluzione ottima prevede invece che sia possibile selezionare entrambi gli eventi più lunghi.

\subsubsection*{Algoritmo 2}

Un'altra idea potrebbe essere quella di selezionare
il prossimo evento che \emph{inizia} il \emph{prima} possibile.

Questo algoritmo seleziona i seguenti eventi:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw[fill=lightgray] (2, 0) rectangle (6, -1);
    \draw (4, -1.5) rectangle (10, -2.5);
    \draw[fill=lightgray] (6, -3) rectangle (18, -4);
    \draw (12, -4.5) rectangle (16, -5.5);
    \node at (2.5,-0.5) {$A$};
    \node at (4.5,-2) {$B$};
    \node at (6.5,-3.5) {$C$};
    \node at (12.5,-5) {$D$};
  \end{scope}
\end{tikzpicture}
\end{center}
 
Si riesce comunque a trovare un controesempio anche 
per questo algoritmo.
Ad esempio, per i seguenti valori,
l'algoritmo seleziona un solo evento:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw[fill=lightgray] (1, 0) rectangle (14, -1);
    \draw (3, -1.5) rectangle (7, -2.5);
    \draw (8, -3) rectangle (12, -4);
  \end{scope}
\end{tikzpicture}
\end{center}
Selezionando il primo evento non è poi possibile
selezionarne nessun altro, dove invece la soluzione ottima
contiene due eventi.

\subsubsection*{Algoritmo 3}

La terza idea è quella di selezionare il prossimo 
evento che \emph{finisce} il \emph{prima} possibile.

Questo algoritmo seleziona i seguenti eventi:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw[fill=lightgray] (2, 0) rectangle (6, -1);
    \draw (4, -1.5) rectangle (10, -2.5);
    \draw (6, -3) rectangle (18, -4);
    \draw[fill=lightgray] (12, -4.5) rectangle (16, -5.5);
    \node at (2.5,-0.5) {$A$};
    \node at (4.5,-2) {$B$};
    \node at (6.5,-3.5) {$C$};
    \node at (12.5,-5) {$D$};
  \end{scope}
\end{tikzpicture}
\end{center}

Si può dimostrare che questo algoritmo produce
\emph{sempre} una soluzione ottimale.
Il motivo per cui funziona è che selezionare l'evento 
che termina per primo è una scelta ottima anche
globalmente.
Se successivamente si seleziona il prossimo evento
scegliendo quello che termina per primo tra quelli rimasti
si arriva ancora a una scelta ottima globale e continuando 
così fino a quando non si possono selezionare ulteriori eventi
si arriva alla soluzione ottima.

Un modo per dimostrare che l'algoritmo funziona
è di considerare cosa succede se al posto di selezionare
l'evento che finisce il prima possibile se 
ne seleziona uno che finisce dopo.
In questo caso il numero di ulteriori scelte possibili
non può che essere uguale o minore a quelle che si sarebbero
ottenute selezionando l'evento che termina per primo
e quindi non si potrà ottenere una soluzione migliore,
quindi questo algoritmo greedy è corretto.

\section{Tasks and deadlines}

Let us now consider a problem where
we are given $n$ tasks with durations and deadlines
and our task is to choose an order to perform the tasks.
For each task, we earn $d-x$ points
where $d$ is the task's deadline
and $x$ is the moment when we finish the task.
What is the largest possible total score
we can obtain?

For example, suppose that the tasks are as follows:
\begin{center}
\begin{tabular}{lll}
task & duration & deadline \\
\hline
$A$ & 4 & 2 \\
$B$ & 3 & 5 \\
$C$ & 2 & 7 \\
$D$ & 4 & 5 \\
\end{tabular}
\end{center}
In this case, an optimal schedule for the tasks
is as follows:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw (0, 0) rectangle (4, -1);
    \draw (4, 0) rectangle (10, -1);
    \draw (10, 0) rectangle (18, -1);
    \draw (18, 0) rectangle (26, -1);
    \node at (0.5,-0.5) {$C$};
    \node at (4.5,-0.5) {$B$};
    \node at (10.5,-0.5) {$A$};
    \node at (18.5,-0.5) {$D$};

    \draw (0,1.5) -- (26,1.5);
    \foreach \i in {0,2,...,26}
    {
        \draw (\i,1.25) -- (\i,1.75);
    }
    \footnotesize
    \node at (0,2.5) {0};
    \node at (10,2.5) {5};
    \node at (20,2.5) {10};

  \end{scope}
\end{tikzpicture}
\end{center}
In this solution, $C$ yields 5 points,
$B$ yields 0 points, $A$ yields $-7$ points
and $D$ yields $-8$ points,
so the total score is $-10$.

Surprisingly, the optimal solution to the problem
does not depend on the deadlines at all,
but a correct greedy strategy is to simply
perform the tasks \emph{sorted by their durations}
in increasing order.
The reason for this is that if we ever perform
two tasks one after another such that the first task
takes longer than the second task,
we can obtain a better solution if we swap the tasks.
For example, consider the following schedule:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw (0, 0) rectangle (8, -1);
    \draw (8, 0) rectangle (12, -1);
    \node at (0.5,-0.5) {$X$};
    \node at (8.5,-0.5) {$Y$};

\draw [decoration={brace}, decorate, line width=0.3mm] (7.75,-1.5) -- (0.25,-1.5);
\draw [decoration={brace}, decorate, line width=0.3mm] (11.75,-1.5) -- (8.25,-1.5);

\footnotesize
\node at (4,-2.5) {$a$};
\node at (10,-2.5) {$b$};

  \end{scope}
\end{tikzpicture}
\end{center}
Here $a>b$, so we should swap the tasks:
\begin{center}
\begin{tikzpicture}[scale=.4]
  \begin{scope}
    \draw (0, 0) rectangle (4, -1);
    \draw (4, 0) rectangle (12, -1);
    \node at (0.5,-0.5) {$Y$};
    \node at (4.5,-0.5) {$X$};

\draw [decoration={brace}, decorate, line width=0.3mm] (3.75,-1.5) -- (0.25,-1.5);
\draw [decoration={brace}, decorate, line width=0.3mm] (11.75,-1.5) -- (4.25,-1.5);

\footnotesize
\node at (2,-2.5) {$b$};
\node at (8,-2.5) {$a$};

  \end{scope}
\end{tikzpicture}
\end{center}
Now $X$ gives $b$ points less and $Y$ gives $a$ points more,
so the total score increases by $a-b > 0$.
In an optimal solution,
for any two consecutive tasks,
it must hold that the shorter task comes
before the longer task.
Thus, the tasks must be performed
sorted by their durations.

\section{Minimizing sums}

We next consider a problem where
we are given $n$ numbers $a_1,a_2,\ldots,a_n$
and our task is to find a value $x$
that minimizes the sum
\[|a_1-x|^c+|a_2-x|^c+\cdots+|a_n-x|^c.\]
We focus on the cases $c=1$ and $c=2$.

\subsubsection{Case $c=1$}

In this case, we should minimize the sum
\[|a_1-x|+|a_2-x|+\cdots+|a_n-x|.\]
For example, if the numbers are $[1,2,9,2,6]$,
the best solution is to select $x=2$
which produces the sum
\[
|1-2|+|2-2|+|9-2|+|2-2|+|6-2|=12.
\]
In the general case, the best choice for $x$
is the \textit{median} of the numbers,
i.e., the middle number after sorting.
For example, the list $[1,2,9,2,6]$
becomes $[1,2,2,6,9]$ after sorting,
so the median is 2.

The median is an optimal choice,
because if $x$ is smaller than the median,
the sum becomes smaller by increasing $x$,
and if $x$ is larger then the median,
the sum becomes smaller by decreasing $x$.
Hence, the optimal solution is that $x$
is the median.
If $n$ is even and there are two medians,
both medians and all values between them
are optimal choices.

\subsubsection{Case $c=2$}

In this case, we should minimize the sum
\[(a_1-x)^2+(a_2-x)^2+\cdots+(a_n-x)^2.\]
For example, if the numbers are $[1,2,9,2,6]$,
the best solution is to select $x=4$
which produces the sum
\[
(1-4)^2+(2-4)^2+(9-4)^2+(2-4)^2+(6-4)^2=46.
\]
In the general case, the best choice for $x$
is the \emph{average} of the numbers.
In the example the average is $(1+2+9+2+6)/5=4$.
This result can be derived by presenting
the sum as follows:
\[
nx^2 - 2x(a_1+a_2+\cdots+a_n) + (a_1^2+a_2^2+\cdots+a_n^2)
\]
The last part does not depend on $x$,
so we can ignore it.
The remaining parts form a function
$nx^2-2xs$ where $s=a_1+a_2+\cdots+a_n$.
This is a parabola opening upwards
with roots $x=0$ and $x=2s/n$,
and the minimum value is the average
of the roots $x=s/n$, i.e.,
the average of the numbers $a_1,a_2,\ldots,a_n$.

\section{Data compression}

\index{data compression}
\index{binary code}
\index{codeword}

A \key{binary code} assigns for each character
of a string a \key{codeword} that consists of bits.
We can \emph{compress} the string using the binary code
by replacing each character by the
corresponding codeword.
For example, the following binary code
assigns codewords for characters
\texttt{A}–\texttt{D}:
\begin{center}
\begin{tabular}{rr}
character & codeword \\
\hline
\texttt{A} & 00 \\
\texttt{B} & 01 \\
\texttt{C} & 10 \\
\texttt{D} & 11 \\
\end{tabular}
\end{center}
This is a \key{constant-length} code
which means that the length of each
codeword is the same.
For example, we can compress the string
\texttt{AABACDACA} as follows:
\[00\,00\,01\,00\,10\,11\,00\,10\,00\]
Using this code, the length of the compressed
string is 18 bits.
However, we can compress the string better
if we use a \key{variable-length} code
where codewords may have different lengths.
Then we can give short codewords for
characters that appear often
and long codewords for characters
that appear rarely.
It turns out that an \key{optimal} code
for the above string is as follows:
\begin{center}
\begin{tabular}{rr}
character & codeword \\
\hline
\texttt{A} & 0 \\
\texttt{B} & 110 \\
\texttt{C} & 10 \\
\texttt{D} & 111 \\
\end{tabular}
\end{center}
An optimal code produces a compressed string
that is as short as possible.
In this case, the compressed string using
the optimal code is
\[0\,0\,110\,0\,10\,111\,0\,10\,0,\]
so only 15 bits are needed instead of 18 bits.
Thus, thanks to a better code it was possible to
save 3 bits in the compressed string.

We require that no codeword
is a prefix of another codeword.
For example, it is not allowed that a code
would contain both codewords 10
and 1011.
The reason for this is that we want
to be able to generate the original string
from the compressed string.
If a codeword could be a prefix of another codeword,
this would not always be possible.
For example, the following code is \emph{not} valid:
\begin{center}
\begin{tabular}{rr}
character & codeword \\
\hline
\texttt{A} & 10 \\
\texttt{B} & 11 \\
\texttt{C} & 1011 \\
\texttt{D} & 111 \\
\end{tabular}
\end{center}
Using this code, it would not be possible to know
if the compressed string 1011 corresponds to
the string \texttt{AB} or the string \texttt{C}.

\index{Huffman coding}

\subsubsection{Huffman coding}

\key{Huffman coding}\footnote{D. A. Huffman discovered this method
when solving a university course assignment
and published the algorithm in 1952 \cite{huf52}.} is a greedy algorithm
that constructs an optimal code for
compressing a given string.
The algorithm builds a binary tree
based on the frequencies of the characters
in the string,
and each character's codeword can be read
by following a path from the root to
the corresponding node.
A move to the left corresponds to bit 0,
and a move to the right corresponds to bit 1.

Initially, each character of the string is
represented by a node whose weight is the
number of times the character occurs in the string.
Then at each step two nodes with minimum weights
are combined by creating
a new node whose weight is the sum of the weights
of the original nodes.
The process continues until all nodes have been combined.

Next we will see how Huffman coding creates
the optimal code for the string
\texttt{AABACDACA}.
Initially, there are four nodes that correspond
to the characters of the string:

\begin{center}
\begin{tikzpicture}[scale=0.9]
\node[draw, circle] (1) at (0,0) {$5$};
\node[draw, circle] (2) at (2,0) {$1$};
\node[draw, circle] (3) at (4,0) {$2$};
\node[draw, circle] (4) at (6,0) {$1$};

\node[color=blue] at (0,-0.75) {\texttt{A}};
\node[color=blue] at (2,-0.75) {\texttt{B}};
\node[color=blue] at (4,-0.75) {\texttt{C}};
\node[color=blue] at (6,-0.75) {\texttt{D}};

%\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
The node that represents character \texttt{A}
has weight 5 because character \texttt{A}
appears 5 times in the string.
The other weights have been calculated
in the same way.

The first step is to combine the nodes that
correspond to characters \texttt{B} and \texttt{D},
both with weight 1.
The result is:
\begin{center}
\begin{tikzpicture}[scale=0.9]
\node[draw, circle] (1) at (0,0) {$5$};
\node[draw, circle] (3) at (2,0) {$2$};
\node[draw, circle] (2) at (4,0) {$1$};
\node[draw, circle] (4) at (6,0) {$1$};
\node[draw, circle] (5) at (5,1) {$2$};

\node[color=blue] at (0,-0.75) {\texttt{A}};
\node[color=blue] at (2,-0.75) {\texttt{C}};
\node[color=blue] at (4,-0.75) {\texttt{B}};
\node[color=blue] at (6,-0.75) {\texttt{D}};

\node at (4.3,0.7) {0};
\node at (5.7,0.7) {1};

\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\end{tikzpicture}
\end{center}
After this, the nodes with weight 2 are combined:
\begin{center}
\begin{tikzpicture}[scale=0.9]
\node[draw, circle] (1) at (1,0) {$5$};
\node[draw, circle] (3) at (3,1) {$2$};
\node[draw, circle] (2) at (4,0) {$1$};
\node[draw, circle] (4) at (6,0) {$1$};
\node[draw, circle] (5) at (5,1) {$2$};
\node[draw, circle] (6) at (4,2) {$4$};

\node[color=blue] at (1,-0.75) {\texttt{A}};
\node[color=blue] at (3,1-0.75) {\texttt{C}};
\node[color=blue] at (4,-0.75) {\texttt{B}};
\node[color=blue] at (6,-0.75) {\texttt{D}};

\node at (4.3,0.7) {0};
\node at (5.7,0.7) {1};
\node at (3.3,1.7) {0};
\node at (4.7,1.7) {1};

\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (3) -- (6);
\path[draw,thick,-] (5) -- (6);
\end{tikzpicture}
\end{center}
Finally, the two remaining nodes are combined:
\begin{center}
\begin{tikzpicture}[scale=0.9]
\node[draw, circle] (1) at (2,2) {$5$};
\node[draw, circle] (3) at (3,1) {$2$};
\node[draw, circle] (2) at (4,0) {$1$};
\node[draw, circle] (4) at (6,0) {$1$};
\node[draw, circle] (5) at (5,1) {$2$};
\node[draw, circle] (6) at (4,2) {$4$};
\node[draw, circle] (7) at (3,3) {$9$};

\node[color=blue] at (2,2-0.75) {\texttt{A}};
\node[color=blue] at (3,1-0.75) {\texttt{C}};
\node[color=blue] at (4,-0.75) {\texttt{B}};
\node[color=blue] at (6,-0.75) {\texttt{D}};

\node at (4.3,0.7) {0};
\node at (5.7,0.7) {1};
\node at (3.3,1.7) {0};
\node at (4.7,1.7) {1};
\node at (2.3,2.7) {0};
\node at (3.7,2.7) {1};

\path[draw,thick,-] (2) -- (5);
\path[draw,thick,-] (4) -- (5);
\path[draw,thick,-] (3) -- (6);
\path[draw,thick,-] (5) -- (6);
\path[draw,thick,-] (1) -- (7);
\path[draw,thick,-] (6) -- (7);
\end{tikzpicture}
\end{center}

Now all nodes are in the tree, so the code is ready.
The following codewords can be read from the tree:
\begin{center}
\begin{tabular}{rr}
character & codeword \\
\hline
\texttt{A} & 0 \\
\texttt{B} & 110 \\
\texttt{C} & 10 \\
\texttt{D} & 111 \\
\end{tabular}
\end{center}