\chapter{Introduzione}

La programmazione competitiva\footnote{Nel testo originale inglese viene spesso utilizzato il termine "competitive programming", che qui viene tradotto come "programmazione competitiva": in Italia il termine non è molto utilizzato nemmeno in ambito  informatico, ma mi è sembrata l'alternativa migliore.(N.d.T.)}  è composta da due aspetti:
(1) la progettazione di algoritmi e (2) l'implementazione di algoritmi.

Il \key{progetto di algoritmi} richiede capacità di problem solving
e utilizzo del pensiero logico-matematico.
Sono richieste capacità di analizzare problemi e di 
risolverli in maniera creativa.
L'algoritmo risolutivo di un problema
deve essere sia corretto che efficiente,
e l'aspetto principale del problema è spesso
quello di inventare un algoritmo efficiente.

La conoscenza teorica degli algoritmi è
importante per dei programmatori che affrontano gare:
tipicamente la soluzione di un problema è ottenuta 
combinando tecniche ben conosciute con nuove intuizioni.
Le tecniche utilizzate nella programmazione competitiva
sono anche alla base della ricerca scientifica sugli
algoritmi.

L'\key{implementazione di algoritmi} richiede buone
capacità di programmazione.
Nella programmazione competitiva, le soluzioni sono valutate
attraverso una serie di casi di test applicati all'algoritmo 
che è stato implementato.
Quindi, non solo l'idea risolutiva deve essere corretta,
ma lo deve essere anche l'implementazione.

Un stile di programmazione adatto alle gare
deve essere diretto e conciso.
I programmi dovono essere scritti velocemente,
perchè il tempo disponibile è limitato.
A differenza dell'ingegneria del software tradizionale,
i programmi sono corti (tipicamente sono lunghi qualche
centinaio di linee al massimo) e non hanno bisogno
di manutenzione una volta che sia finita la gara.

\section{Linguaggi di programmazione}

\index{linguaggio di programmazione}

Al momento, i linguaggi di programmazione più utilizzati 
nelle gare sono C++, Python e Java.
Per esempio, in Google Code Jam 2017,
tra i migliori 3000 partecipanti,
79 \% hanno usato C++,
16 \% hanno usato Python e
8 \% hanno usato Java \cite{goo17}.
Sono stati utilizzati inoltre anche altri linguaggi, 
ma questi tre sono decisamente i più popolari

Molte persone pensano che il C++ sia la scelta migliore
per le gare di programmazione e 
il C++ è disponibile in praticamente qualsiasi 
gara di programmazione.
I vantaggi nell'usare il C++ sono che è molto
efficiente e la sua libreria contiene un'enorme
collezione di strutture dati e algoritmi.

D'altro canto, è una cosa buona saper utilizzare
più di un linguaggio e conoscerne i suoi punti di forza.
Per esempio, se nel problema fosse necessario poter
gestire interi enormi, oltre il ristretto range di quelli
gestiti nativamente dal C++, Python potrebbe essere una
buona scelta, perchè è in grado di gestire operazioni
con interi di lunghezza arbitraria.
Inoltre la maggior parte dei problemi delle gare di programmazione
sono pensati per non avvantaggiare nessun particolare
linguaggio.

Tutti gli esempi in questo libro sono scritti in C++,
e vengono spesso usati algortimi e strutture dati 
presenti nella Libreria Standard.
I programmi sono scritti in modo da seguire lo standard C++11, 
che attualmente può essere utilizzato nella maggior parte delle gare.
Se ancora non si è in grado di programmare in C++,
questo è un buon momento per iniziare.

\subsubsection{Un modello di programma C++}

Un tipico modello di programma in C++ che può essere adattato per molte gare
è il seguente:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // solution comes here
}
\end{lstlisting}

La scritta \texttt{\#include} all'inizio del codice
è un'istruzione che istruisce il compilatore \texttt{g++}
a includere l'intera libreria standard.
In questo modo non è più necessario includere separatamente librerie come
\texttt{iostream},\texttt{vector} e \texttt{algorithm},
ma queste saranno automaticamente disponibili.

L'istruzione \texttt{using} dichiara che le classi
e le funzioni della Libreria Standard possono
essere usate direttamente nel codice.
Senza la \texttt{using} sarebbe necessario 
scrivere, per esempio, \texttt{std::cout} per ogni istruzione di output,
mentre in questo modo è sufficiente scrivere \texttt{cout}.

Il codice può essere compilato utilizzando il seguente comando:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Questo comando produce il file binario \texttt{test}
partendo dal codice sorgente \texttt{test.cpp}.
Il compilatore seguirà lo standard C++11 (\texttt{-std=c++11}),
ottimizzerà il codice (\texttt{-O2})
e mostrerà degli warnings che riguardano possibili problemi (\texttt{-Wall}).

\section{Input e output}

\index{input e output}

Nella maggior parte delle gare vengono usati gli stream standard
per le operazioni di lettura/scrittura.
In C++ gli stream standard sono 
\texttt{cin} perl'input e \texttt{cout} per l'ouput.
Inoltre possono essere anche usate le funzioni
\texttt{scanf} e \texttt{printf} ereditate dal C.

Tipicamente l'input del programma consiste di numeri 
e stringhe separati da spazi e a capo.
Questi possono essere letti dallo stream \texttt{cin}
nel modo seguente:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Questo tipo di codice funziona sempre
se si assume che ci sia almeno uno spazio o un a capo
che separa ogni elemento in input.
Ad esempio, il codice appena scritto è in grado 
di leggere ambedue i seguenti input:

\begin{lstlisting}
123 456 monkey
\end{lstlisting}
\begin{lstlisting}
123    456
monkey
\end{lstlisting}

Lo stream \texttt{cout} viene usato per scrivere
in output nel seguente modo: 

\begin{lstlisting}
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

A volte l'input e l'output possono essere dei 
colli di bottiglia per il programma: le seguenti 
linee all'inizio del codice possono rendere 
le operazioni di input e output più efficienti:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Da notare che andare a capo con \texttt{"\textbackslash n"}
è molto più veloce che utilizzando \texttt{endl},
perchè \texttt{endl} produce sempre 
un'operazione di flush del buffer di output.

Le funzioni C \texttt{scanf}
e \texttt{printf} sono un'alternativa ai flussi standard
del C++.
Di solito sono un po' più veloci,
ma sono anche più difficili da usare.
Il codice seguente legge due interi in input:

\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}

Invece il codice seguente stampa due interi:

\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}

Può anche succedere che il programma debba leggere un'intera linea
in input, eventualmente contenente spazi.
Per far questo si può utilizzare la funzione \texttt{getline}:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Se la quantità di dati da leggere fosse sconosciuta,
è utile usare il seguente loop:

\begin{lstlisting}
while (cin >> x) {
    // code
}
\end{lstlisting}
Questo ciclo legge gli elementi dall'input 
uno dopo l'altro, fino a che non rimane niente
da leggere.

In alcune gare, vengono usati i file per
l'input e l'output.
Una semplice soluzione per utilizzarli è
quella di scrivere il codice come se 
si trattasse dei soliti stream di I/O,
premettendo le seguenti linee all'inizio del codice:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Fatto questo, il programma leggerà l'input dal file ''input.txt''
e scriverà l'output sul file ''output.txt''.

\section{Lavorare con i numeri}

\index{interi}

\subsubsection{Interi}

Il tipo di interi più utilizzato nella programmazione competitiva
è l'\texttt{int}, che viene rappresentato con 32 bit e ha un range di
$-2^{31} \ldots 2^{31}-1$ o circa $-2 \cdot 10^9 \ldots 2 \cdot 10^9$.
Se il tipo \texttt{int} non è abbastanza, 
può essere utilizzato il tipo a 64 bit, dichiarato con \texttt{long long}.
Il suo range è  $-2^{63} \ldots 2^{63}-1$ o circa
$-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$.

Il codice seguente definisce una variabile 
di tipo \texttt{long long} 

\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}

Il suffisso \texttt{LL} significa che il 
tipo del numero è \texttt{long long}.

Un errore comune quando viene utilizzato il tipo 
\texttt{long long} è che in altre parti del codice
possono ancora esserci delle variabili di tipo \texttt{int}.
Per esempio il codice seguente contiene un errore
non facile da individuare: 

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

Anche se la variabile \texttt{b} è di tipo \texttt{long long},
entrambi i numeri nell'espressione \texttt{a*a}
sono di tipo \texttt{int} e il risultato risulta
anch'esso di tipo \texttt{int}.
Quindi la variabile \texttt{b} conterrà
un risultato non corretto.
Il problema può essere risolto cambiando il tipo 
della variabile \texttt{a} da \texttt{int} a \texttt{long long}
oppure cambiando l'espressione attraverso l'operatore di casting,
facendola diventare \texttt{(long long)a*a}.

Normalmente i problemi di gara sono costruiti in modo
che il tipo \texttt{long long} sia sufficiente.
Può però essere utile sapere che il compilatore \texttt{g++}
fornisce anche un tipo a 128 bit, \texttt{\_\_int128\_t},
il cui range è $-2^{127} \ldots 2^{127}-1$ o circa
$-10^{38} \ldots 10^{38}$.
Comunque questo tipo non è presente in tutti i sistemi di gara.

\subsubsection{Aritmetica modulare}

\index{resto}
\index{aritmetica modulare}

Il resto della divisione intera tra $x$ e $m$
viene indicato con $x \bmod m$.
Per esempio $17 \bmod 5 = 2$,
poichè $17 = 3 \cdot 5 + 2$.

A volte la risposta a un problema è un numero molto 
grande e quindi viene chiesto di dare in output
il numero ''modulo $m$'', cioè il resto
della risposta quando il numero grande è diviso per $m$
(per esempio ''modulo $10^9+7$'').
L'idea è che se anche la risposta "vera" è molto grande,
risulta sufficiente usare i tipi \texttt{int} e \texttt{long long}
per contenere il resto.

Una proprietà importante del modulo è che
nelle operazioni di addizione,
sottrazione e moltiplicazione, è possibile applicare il modulo
prima di eseguire l'operazione, cioè:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Quindi è possibile prendere il resto di ogni divisione
e in questo modo i numeri non diventeranno mai troppo grandi.

Per esempio, il seguente codice calcola $n!$,
il fattoriale di $n$, modulo $m$:

\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Normalmente si desidera che il resto sia
compreso tra $0\ldots m-1$.
Comunque, in C++ e in altri linguaggi,
il resto di un numero negativo può essere 0 
o un numero negativo. Per evitare questo problema
e assicurarsi di avere sempre a che fare con numeri 
positivi, si può prima calcolare il modulo e poi
aggiungere $m$ se il risultato è negativo:

\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}

La necessità di utilizzare questo genere di codice
si ha soltanto se sono presenti delle sottrazioni e
quindi il resto può diventare negativo.

\subsubsection{Numeri floating point}

\index{numeri floating point}

I tipi floating point utilizzati nelle gare
sono i \texttt{double} a 64 bit e, come estensione del
compilatore \texttt{g++}, i \texttt{long double} a 80 bit.
Nella maggior parte dei casi i \texttt{double} sono sufficienti,
ma i \texttt{long double} sono più precisi.

La precisione richiesta nella risposta è normalmente 
indicata nella descrizione del problema.
Il modo più semplice per stampare la risposta
è quello di usare la funzione \texttt{printf}
e scrivere il numero di cifre decimali nella stringa di formattazione.
Ad esempio il seguente codice stampa
il valore di $x$ con 9 cifre decimali:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Una difficoltà nell'utilizzo dei numeri floating point
è che alcuni numeri non possono essere rappresentati 
accuratamente utilizzando dei numeri floating point,
e quindi ci saranno degli errori di arrotondamento, come
si può vedere nel codice seguente, il cui risultato può sembrare 
sorprendente:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

A causa degli errori di arrotondamento,
il valore di $x$ è leggermente minore di 1,
dove il risultato corretto sarebbe proprio 1.

Confrontare numeri floating point utilizzando
l'operatore \texttt{==} può essere rischioso,
perchè sebbene i valori comparati dovrebbero teoricamente
essere uguali, magari non lo sono a causa di errori di arrotondamento.
Un modo migliore per comfrontare questo tipo di numeri
è quello di assumere che due numeri sono uguali se la differenza fra di loro 
è minore di un certo valore $\varepsilon$ piccolo a piacere.
In pratica il confronto viene fatto in questo modo, con $\varepsilon=10^{-9}$:

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a and b are equal
}
\end{lstlisting}

Da notare che nonostante i numeri floating point siano imprecisi,
gli interi fino a un certo valore possono comunque essere rappresentati accuratamente.
Per esempio, usando il tipo \texttt{double}, 
è possibile rappresentare accuratamente tutti gli interi il cui valore
assoluto sia minore o uguale a $2^{53}$.

\section{Scrivere codice conciso}

Nelle gare di programmazione è essenziale scrivere codice breve,
poichè i programmi dovrebbero essere scritti nel minor tempo possibile.
Per questo i programmatori usano spesso nomi brevi per
i tipi di dati e altre parti del codice.

\subsubsection{Abbreviare le dichiarazioni}
\index{tuppdef@\texttt{typedef}}
In C++ è possibile definire un nuovo nome più corto
a un tipo di dato già esistente
utilizzando la parola chiave \texttt{typedef}

Ad esempio, dato che il nome \texttt{long long} è lungo,
può essere ridefinito per brevità come \texttt{ll} nel seguente modo:

\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Dopo questa definizione, il codice:
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
potrà essere riscritto come:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

Il comando \texttt{typedef} può essere usato
anche per definire tipi di dati complessi.
Per esempio, il seguente codice assegna il nome \texttt{vi}
a un vettore di interi e il nome \texttt{pi} a un paio che contiene
una coppia di interi.

\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Macro}
\index{macro}
Un altro modo per scrivere codice più corto
è quello di definire delle \key{macro}.
Una macro indica che una certa stringa di codice
sarà sostituita con un'altra prima della compilazione.
In C++ le macro vengono definite usando la parola
chiave \texttt{\#define}.

Se ad esempio vengono definite queste macro:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
allora il codice:
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
potrà essere accorciato nel modo seguente:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Una macro può anche avere dei parametri, 
il che rende possibile la scrittura di loop
più corti e di altre strutture.
Definendo ad esempio la seguente macro:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
il codice:
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
risulterà così abbreviato:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

A volte le macro possono creare degli errori
difficili da individuare.
Si prenda ad esempio la macro che calcola 
il quadrato di un numero: 

\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Questa macro \emph{non} sempre si comporta come ci si aspetterebbe:
ad esempio il codice

\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corrisponde al codice
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Quella che segue è una versione corretta della stessa macro:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ora il codice
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corrisponderà al codice
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}


\section{Matematica}

La matematica gioca un ruolo importante 
nelle gare di programmazione e non è possibile 
diventare un ottenere dei buoni risultati
senza avere delle buone capacità matematiche.
In questa sezione verranno discussi alcuni 
importanti concetti matematiche e alcune formule 
che saranno necessarie nel proseguio del testo.

\subsubsection{Formule per le sommatorie}

Ogni somma della forma
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
dove $k$ è un intero positivo, ha una soluzione in forma chiusa
che è un polinomio di grado $k+1$.
Per esempio\footnote{\index{formula di Faulhaber}
C'è anche una formula generale per questo tipo di sommatorie, chiamata \key{formula di Faulhaber},
ma è troppo complessa per essere presentata qui,},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
e
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

Una \key{progressione aritmetica} è una \index{progressione aritmetica}
sequenza di numeri
dove la differenza tra due qualsiasi numeri consecutivi è costante.
Per esempio,
\[3, 7, 11, 15\]
è una progressione aritmetica con costante 4.
La somma di una progressione aritmetica può essere calcolata
usando la formula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{numbers}} = \frac{n(a+b)}{2}\]
dove $a$ è il primo numero,
$b$ è l'ultimo numero e 
$n$ è la quantità di numeri.
Per esempio
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
La formula è basata sul fatto che 
la somma consiste di $n$ numeri e il valore di
ogni elemento in media è $(a+b)/2$

\index{progressione geometrica}
Una \key{progressione geometrica} è una sequenza di numeri
dove il rapporto tra due qualsiasi termini consecutivi 
è costante.
Per esempio,
\[3,6,12,24\]
è una progressione geometrica con costante 2.
La somma si una progressione geometrica può essere calcolata
usando la seguente formula:
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
dove $a$ è il primo numero,
$b$ è l'ultimo numero e il rapporto
tra due numeri consecutivi è $k$.
Per esempio,

\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]

Questa formula si ottiene nel seguente modo. 
Sia
\[ S = a + ak + ak^2 + \cdots + b .\]
Moltiplicando entrambi i lati per $k$ si ottiene
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
e risolvendo l'equazione
\[ kS-S = bk-a\]
si arriva alla formula vista in precedenza.

Un caso speciale della somma di una progressione geometrica 
è la formula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{somma armonica}

Una \key{somma armonica} è una somma della forma
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

Il limite superiore di una somma armonica è $\log_2(n)+1$.
che si ottiene modificando ogni termine $1/k$  in modo che
$k$ diventi la più grande potenza del 2 che non sia maggiore di $k$.
Per esempio,se $n=6$, una stima della formula porta a: 
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Questo limite superiore consiste di $\log_2(n)+1$ parti
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, ecc.),
e il valore di ognuno di questi termini è al massimo 1.

\subsubsection{Teoria degli insiemi}

\index{teoria degli insiemi}
\index{insieme}
\index{intersezione}
\index{unione}
\index{differenza}
\index{sottoinsieme}
\index{insieme universale}
\index{complemento}

Un \key{insieme} (\key{set} in inglese) è una collezione di elementi.
Per esempio, l'insieme
\[X=\{2,4,7\}\]
contiene gli elementi 2, 4 e 7.
Il simbolo $\emptyset$ denota l'insieme vuoto,
e $|S|$ rappresenta la dimensione dell'insieme $S$,
cioè il numero di elementi dell'insieme.
Per esempio, nell'insieme definito prima,
$|X|=3$. 

Se un insieme $S$ contiene l'elemento $x$, 
allora si scrive $x \in S$, 
altrimenti si scrive $x \notin S$.
Sempre con riferimento all'insieme definito prima
\[4 \in X \hspace{10px}\textrm{and}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Nuovi insiemi possono essere definiti attraverso le seguenti operazioni:
\begin{itemize}
\item L'\key{intersezione} $A \cap B$ è formata dagli elementi
presenti sia in $A$ che in $B$.
Per esempio, se $A=\{1,2,5\}$ e $B=\{2,4\}$,
allora $A \cap B = \{2\}$.
\item L'\key{unione} $A \cup B$ è formata dagli elementi che
si trovano in $A$ o in $B$ o in entrambi.
Per esempio, se $A=\{3,7\}$ e $B=\{2,3,8\}$,
allora $A \cup B = \{2,3,7,8\}$.
\item L'\key{insieme complementare} di A, $\bar A$,  consiste degli elementi
che non sono in $A$.
L'interpretazione di cosa sia il complemento di un insieme dipende
dallla definizione che viene data all'\key{insieme universo}, che contiene tutti i possibili elementi.
Per esempio, se $A=\{1,2,5,7\}$ e l'insieme universo è
$\{1,2,\ldots,10\}$, allora $\bar A = \{3,4,6,8,9,10\}$.
\item La \key{differenza} $A \setminus B = A \cap \bar B$
è formata dagli elementi che appartengono ad $A$ ma non a $B$.
Va notato che $B$ può contenere elementi che non sono contenuti in $A$.
Per esempio, se $A=\{2,3,7,8\}$ e $B=\{3,5,8\}$,
allora $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

Se ogni elemento di $A$ appartiene anche a $S$,
si dice che $A$ è un \key{sottoinsieme} di $S$
e si scrive $A \subset S$.
Un insieme $S$ ha $2^{|S|}$ sottoinsiemi,
incluso l'insieme vuoto.
Per esempio, i sottoinsiemi dell'insieme $\{2,4,7\}$ sono
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ e $\{2,4,7\}$.
\end{center}

Gli insieme che vengono usati più frequentemente sono
$\mathbb{N}$ (numeri naturali),
$\mathbb{Z}$ (interi),
$\mathbb{Q}$ (numeri razionali) e
$\mathbb{R}$ (numeri reali).
L'insieme $\mathbb{N}$
può essere definito in due modi, a seconda del contesto:
o come $\mathbb{N}=\{0,1,2,\ldots\}$
oppure $\mathbb{N}=\{1,2,3,...\}$.

Un insieme può anche essere definito utilizzando una regola in questo modo: 
\[\{f(n) : n \in S\},\]
dove $f(n)$ è una qualche funzione.
Questo insieme contiene tutti gli elementi della forma $f(n)$,
dove $n$ è un elemento in $S$.
Per esempio l'insieme
\[X=\{2n : n \in \mathbb{Z}\}\]
contiene tutti gli interi pari.

\subsubsection{Logica}

\index{logica}
\index{negazione}
\index{congiunzione}
\index{disgiunzione}
\index{implicazione}
\index{equivalenza}

Il valore di un'espressione logica può essere solo
\key{true} (1 - vero) o \key{false} (0 - falso).
Gli operatori logici più importanti sono i seguenti: 
$\lnot$ (\key{negazione}), 
$\land$ (\key{congiunzione}), 
$\lor$ (\key{disgiunzine}), 
$\Rightarrow$ (\key{implicazione}) e
$\Leftrightarrow$ (\key{equivalenza}).
La tabella mostra il significato di questi operatori:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

L'espressione $\lnot A$ ha il valore opposto di $A$.
L'espressione $A \land B$ è vera solo se sia $A$ che $B$ sono veri,
mentre l'espressione $A \lor B$ è vera se è vero $A$ o è vero $B$ o sono veri entrambi.
Se l'espressione $A \Rightarrow B$ è vera
allora ogni volta che $A$ è vera, anche $B$ deve essere vera.
Infine l'espressione $A \Leftrightarrow B$ è vera
se $A$ e $B$ sono entrambe vere o entrambe false.

\index{predicato}

Un \key{predicato} è un'espressione che è vera o falsa in base
al valore assunto dai propri parametri.
Normalmente i predicati sono indicati con delle lettere maiuscole.
Per esempio, si può definire il predicato $P(x)$
che risulta vero quando $x$ è un numero primo.
Usando questa definizione, $P(7)$ è vero, invece $P(8)$ non lo è.


\index{quantificatore}

Un \key{quantificatore} connette un'espressione logica 
agli elementi di un insieme. 
I quantificatori più importanti sono
$\forall$ (\key{per ogni}) e $\exists$ (\key{esiste}).
Per esempio,
\[\forall x (\exists y (y < x))\]
significa che per ogni elemento $x$ dell'insieme,
esiste un elemento $y$ dell'insieme tale che
$y$ è minore di $x$.
Questo è vero per l'insieme dei numeri interi, 
ma non lo è per l'insieme dei numeri naturali. 

Usando la notazione appena esposta è possibile
esprimere diversi tipi di proposizioni logiche.
Per esempio,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
significa che per ogni numero $x$ maggiore di 1 non primo,
esistono sempre due numeri $a$ e $b$ maggiori di 1 tali che
il loro prodotto sia uguale a $x$.
Questa proposizione è vera per l'insieme dei numeri interi.

\subsubsection{Funzioni}
La funzione $\lfloor x \rfloor$ arrotonda il numero $x$
all'intero inferiore e la funzione
$\lceil x \rceil$ arrotonda il numero $x$
all'intero superiore. 
Per esempio,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{and} \hspace{10px} \lceil 3/2 \rceil = 2.\]

Le funzioni $\min(x_1,x_2,\ldots,x_n)$
e $\max(x_1,x_2,\ldots,x_n)$
restituiscono il minimo e il massimo dei valori in
$x_1,x_2,\ldots,x_n$.
Per esempio,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{and} \hspace{10px} \max(1,2,3)=3.\]

\index{fattoriale}

Il \key{fattoriale} $n!$ può essere definito come
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
oppure ricorsivamente come
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{numero di Fibonacci}

I \key{numeri di Fibonacci}
%\footnote{Fibonacci (c. 1175--1250) era un matematico italiano.}
possono essere trovati in molte situazioni.
Possono essere definiti in maniera ricorsiva nel seguente modo:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
I primi numeri di Fibonacci sono
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
C'è anche una formula chiusa per il calcolo 
dell'n-esimo numero di Fibonacci, che viene chiamata
There is also a closed-form formula
\index{formula di Binet} \key{formula di Binet}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logaritmi}

\index{logaritmi}

Il \key{logaritmo} di un numero $x$
è indicato con $\log_k(x)$, dove $k$ è la base
del logaritmo.
La definizione prevede che se
$\log_k(x)=a$ allora $k^a=x$.

Un'utile proprietà dei logaritmi
è che il $\log_k(x)$ è uguale al numero di volte
che $x$ deve essere diviso per $k$ prima che il risultato 
diventi 1.
Per esempio,in $\log_2(32)=5$
occorrono 5 divisioni per due prima di ottenere 1:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

I logaritmi sono spesso usati nell'analisi
degli algoritmi, perchè molti algoritmi efficienti
dimezzano un qualche insieme a ogni passo.
Quindi è possibile stimare l'efficienza di questi algoritmi
usando i logaritmi.

Il logaritmo di un prodotto è
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
e di conseguenza,
\[\log_k(x^n) = n \cdot \log_k(x).\]
Inoltre il logaritmo di un quoziente è
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Un'altra formula utile è
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
e usandola è possibile calcolare
logaritmi con ogni base se si è in grado
di calcolare i logaritmi in una qualche base fissata.

\index{logaritmo naturale}

Il \key{logaritmo naturale} $\ln(x)$ di un numero $x$
è il logaritmo la cui base è $e \approx 2.71828$.
Un'altra proprietà del logaritmo è che il numero di cifre
di un intero $x$ in base $b$ è
$\lfloor \log_b(x)+1 \rfloor$.
Ad esempio, la rappresentazione di
$123$ in base $2$ è 1111011 e
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Gare e risorse}

\subsubsection{IOI}

Le Olimpiadi Internazionali di Informatica (IOI)
è una gara di programmazione a cadenza annuale per studenti delle scuole secondarie.
Ogni Paese può mandare una squadra composta da quattro studenti alla gara.
Solitamente ci sono circa 300 partecipanti da circa 80 nazioni.

Le IOI consistono in due gare della durata di 5 ore ciascuna.
In ogni gara ai partecipanti viene richiesto di risolvere tre 
problemi di tipo algoritmico di varie difficoltà.
I problemi sono divisi in sottoproblemi,
ad ognuno dei quali è assegnato un certo punteggio.
Anche se i partecipanti fanno parte di una squadra,
la gara è individuale.

Il syllabus delle IOI \cite{iois} indica quali
argomenti possono comparire nei problemi.
Questo libro tratta di quasi tutti gli argomenti del syllabus.

I partecipanti alle IOI sono selezionati attraverso
delle gare a livello nazionale.
Prima delle IOI venivano organizzate molte gare
a livello regionale, come le Baltic Olympiad in Informatics (BOI),
le Central European Olympiad in Informatics (CEOI) e le
Asia-Pacific Informatics Olympiad (APIO).

Alcune nazioni organizzano gare online di allenamento 
per i futuri partecipanti alle IOI,
come le Croatian Open Competition in Informatics \cite{coci}
e le USA Computing Olympiad \cite{usaco}.
Infine numerosi problemi delle gare organizzate dalla Polonia
sono disponibili online \cite{main}.

\subsubsection{ICPC}

L'International Collegiate Programming Contest (ICPC)
è una gara di programmazione con cadenza annuale per studenti universitari.
Ogni squadra è formata da tre studenti e, a differenza delle IOI,
gli studenti lavorano insieme utilizzando un solo computer.

L'ICPC prevede diverse fasi, alle fine delle quali 
i migliori team sono invitati alle World Finals.
I partecipanti alla gara sono decine di migliaia, 
ma i posti per le finali sono pochi \footnote{Il numero esatto di posti alle finali è diverso ogni anno: nel 2017 
c'erano 133 posti in finale.},
così anche solo arrivare alle finali può essere un
grande risultato per alcune nazioni. 

In ogni gara ICPC, le squadre hanno cinque ore per risolvere 
dieci problemi di tipo algoritmico.
Una soluzione viene accettata solo se risolve tutti i casi di test
efficientemente.
Durante la gara ogni team può vedere i risultati degli altri team,
ma quando manca un'ora alla fine la classifica viene congelata, 
in modo da non mostrare i risultati delle ultime sottoposizioni. 

Gli argomenti che possono comparire all'ICPC non sono
ben specificati come quelli delle IOI.
Comunque è chiaro che vengono richieste più conoscenze,
soprattutto quelle matematiche.

\subsubsection{Gare online}

Ci sono molte gare online a cui può partecipare chiunque.
Il sito di gara più attivo al momento è Codeforces,
che organizza gare con cadenza più o meno settimanale. 
Nelle gare di Codeforces, i partecipanti sono divisi in due categorie:
i principianti competono nella Div2, mentre quelli esperti nella Div1.
Altri siti che organizzano gare sono AtCoder, CS Academy, HackerRank e Topcoder.

Alcune aziende organizzano gare online che prevedono la fase finale in presenza.
Alcuni esempi di queste gare sono la Facebook Hacker Cup,
Google Code Jam e Yandex.Algorithm.
Naturalmente queste aziende usano le proprie gare anche per selezionare
programmatori per un'eventuale assunzione:
ottenere dei risultati in queste gare è un buon modo
per dimostrare le proprie abilità.

\subsubsection{Libri}

Oltre a questo libro esistono alcuni libri che
sono dedicati alla programmazione competitiva e al problem solving:

\begin{itemize}
\item S. S. Skiena and M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

I primi due libri sono per principianti,
mentre l'ultimo contiene materiale più complesso.

Anche libri di carattere generale sugli algoritmi possono
essere utili per queste gare. Alcuni fra i più popolari sono:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
