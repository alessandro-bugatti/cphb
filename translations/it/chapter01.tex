\chapter{Introduzione}

La programmazione competitiva\footnote{Nel testo originale inglese viene spesso utilizzato il termine "competitive programming", che qui viene tradotto come "programmazione competitiva": in Italia il termine non è molto utilizzato nemmeno in ambito  informatico, ma mi è sembrata l'alternativa migliore.(N.d.T.)}  è composta da due aspetti:
(1) la progettazione di algoritmi e (2) l'implementazione di algoritmi.

Il \key{progetto di algoritmi} richiede capacità di problem solving
e utilizzo del pensiero logico-matematico.
Sono richieste capacità di analizzare problemi e di 
risolverli in maniera creativa.
L'algoritmo risolutivo di un problema
deve essere sia corretto che efficiente,
e l'aspetto principale del problema è spesso
quello di inventare un algoritmo efficiente.

La conoscenza teorica degli algoritmi è
importante per dei programmatori che affrontano gare:
tipicamente la soluzione di un problema è ottenuta 
combinando tecniche ben conosciute con nuove intuizioni.
Le tecniche utilizzate nella programmazione competitiva
sono anche alla base della ricerca scientifica sugli
algoritmi.

L'\key{implementazione di algoritmi} richiede buone
capacità di programmazione.
Nella programmazione competitiva, le soluzioni sono valutate
attraverso una serie di casi di test applicati all'algoritmo 
che è stato implementato.
Quindi, non solo l'idea risolutiva deve essere corretta,
ma lo deve essere anche l'implementazione.

Un stile di programmazione adatto alle gare
deve essere diretto e conciso.
I programmi dovono essere scritti velocemente,
perchè il tempo disponibile è limitato.
A differenza dell'ingegneria del software tradizionale,
i programmi sono corti (tipicamente sono lunghi qualche
centinaio di linee al massimo) e non hanno bisogno
di manutenzione una volta che sia finita la gara.

\section{Linguaggi di programmazione}

\index{linguaggio di programmazione}

Al momento, i linguaggi di programmazione più utilizzati 
nelle gare sono C++, Python e Java.
Per esempio, in Google Code Jam 2017,
tra i migliori 3000 partecipanti,
79 \% hanno usato C++,
16 \% hanno usato Python e
8 \% hanno usato Java \cite{goo17}.
Sono stati utilizzati inoltre anche altri linguaggi, 
ma questi tre sono decisamente i più popolari

Molte persone pensano che il C++ sia la scelta migliore
per le gare di programmazione e 
il C++ è disponibile in praticamente qualsiasi 
gara di programmazione.
I vantaggi nell'usare il C++ sono che è molto
efficiente e la sua libreria contiene un'enorme
collezione di strutture dati e algoritmi.

D'altro canto, è una cosa buona saper utilizzare
più di un linguaggio e conoscerne i suoi punti di forza.
Per esempio, se nel problema fosse necessario poter
gestire interi enormi, oltre il ristretto range di quelli
gestiti nativamente dal C++, Python potrebbe essere una
buona scelta, perchè è in grado di gestire operazioni
con interi di lunghezza arbitraria.
Inoltre la maggior parte dei problemi delle gare di programmazione
sono pensati per non avvantaggiare nessun particolare
linguaggio.

Tutti gli esempi in questo libro sono scritti in C++,
e vengono spesso usati algortimi e strutture dati 
presenti nella Libreria Standard.
I programmi sono scritti in modo da seguire lo standard C++11, 
che attualmente può essere utilizzato nella maggior parte delle gare.
Se ancora non si è in grado di programmare in C++,
questo è un buon momento per iniziare.

\subsubsection{Un modello di programma C++}

Un tipico modello di programma in C++ che può essere adattato per molte gare
è il seguente:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // solution comes here
}
\end{lstlisting}

La scritta \texttt{\#include} all'inizio del codice
è un'istruzione che istruisce il compilatore \texttt{g++}
a includere l'intera libreria standard.
In questo modo non è più necessario includere separatamente librerie come
\texttt{iostream},\texttt{vector} e \texttt{algorithm},
ma queste saranno automaticamente disponibili.

L'istruzione \texttt{using} dichiara che le classi
e le funzioni della Libreria Standard possono
essere usate direttamente nel codice.
Senza la \texttt{using} sarebbe necessario 
scrivere, per esempio, \texttt{std::cout} per ogni istruzione di output,
mentre in questo modo è sufficiente scrivere \texttt{cout}.

Il codice può essere compilato utilizzando il seguente comando:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Questo comando produce il file binario \texttt{test}
partendo dal codice sorgente \texttt{test.cpp}.
Il compilatore seguirà lo standard C++11 (\texttt{-std=c++11}),
ottimizzerà il codice (\texttt{-O2})
e mostrerà degli warnings che riguardano possibili problemi (\texttt{-Wall}).

\section{Input e output}

\index{input e output}

Nella maggior parte delle gare vengono usati gli stream standard
per le operazioni di lettura/scrittura.
In C++ gli stream standard sono 
\texttt{cin} perl'input e \texttt{cout} per l'ouput.
Inoltre possono essere anche usate le funzioni
\texttt{scanf} e \texttt{printf} ereditate dal C.

Tipicamente l'input del programma consiste di numeri 
e stringhe separati da spazi e a capo.
Questi possono essere letti dallo stream \texttt{cin}
nel modo seguente:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Questo tipo di codice funziona sempre
se si assume che ci sia almeno uno spazio o un a capo
che separa ogni elemento in input.
Ad esempio, il codice appena scritto è in grado 
di leggere ambedue i seguenti input:

\begin{lstlisting}
123 456 monkey
\end{lstlisting}
\begin{lstlisting}
123    456
monkey
\end{lstlisting}

Lo stream \texttt{cout} viene usato per scrivere
in output nel seguente modo: 

\begin{lstlisting}
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

A volte l'input e l'output possono essere dei 
colli di bottiglia per il programma: le seguenti 
linee all'inizio del codice possono rendere 
le operazioni di input e output più efficienti:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Da notare che andare a capo con \texttt{"\textbackslash n"}
è molto più veloce che utilizzando \texttt{endl},
perchè \texttt{endl} produce sempre 
un'operazione di flush del buffer di output.

Le funzioni C \texttt{scanf}
e \texttt{printf} sono un'alternativa ai flussi standard
del C++.
Di solito sono un po' più veloci,
ma sono anche più difficili da usare.
Il codice seguente legge due interi in input:

\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}

Invece il codice seguente stampa due interi:

\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}

Può anche succedere che il programma debba leggere un'intera linea
in input, eventualmente contenente spazi.
Per far questo si può utilizzare la funzione \texttt{getline}:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Se la quantità di dati da leggere fosse sconosciuta,
è utile usare il seguente loop:

\begin{lstlisting}
while (cin >> x) {
    // code
}
\end{lstlisting}
Questo ciclo legge gli elementi dall'input 
uno dopo l'altro, fino a che non rimane niente
da leggere.

In alcune gare, vengono usati i file per
l'input e l'output.
Una semplice soluzione per utilizzarli è
quella di scrivere il codice come se 
si trattasse dei soliti stream di I/O,
premettendo le seguenti linee all'inizio del codice:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Fatto questo, il programma leggerà l'input dal file ''input.txt''
e scriverà l'output sul file ''output.txt''.

\section{Lavorare con i numeri}

\index{interi}

\subsubsection{Interi}

Il tipo di interi più utilizzato nella programmazione competitiva
è l'\texttt{int}, che viene rappresentato con 32 bit e ha un range di
$-2^{31} \ldots 2^{31}-1$ o circa $-2 \cdot 10^9 \ldots 2 \cdot 10^9$.
Se il tipo \texttt{int} non è abbastanza, 
può essere utilizzato il tipo a 64 bit, dichiarato con \texttt{long long}.
Il suo range è  $-2^{63} \ldots 2^{63}-1$ o circa
$-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$.

Il codice seguente definisce una variabile 
di tipo \texttt{long long} 

\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}

Il suffisso \texttt{LL} significa che il 
tipo del numero è \texttt{long long}.

Un errore comune quando viene utilizzato il tipo 
\texttt{long long} è che in altre parti del codice
possono ancora esserci delle variabili di tipo \texttt{int}.
Per esempio il codice seguente contiene un errore
non facile da individuare: 

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

Anche se la variabile \texttt{b} è di tipo \texttt{long long},
entrambi i numeri nell'espressione \texttt{a*a}
sono di tipo \texttt{int} e il risultato risulta
anch'esso di tipo \texttt{int}.
Quindi la variabile \texttt{b} conterrà
un risultato non corretto.
Il problema può essere risolto cambiando il tipo 
della variabile \texttt{a} da \texttt{int} a \texttt{long long}
oppure cambiando l'espressione attraverso l'operatore di casting,
facendola diventare \texttt{(long long)a*a}.

Normalmente i problemi di gara sono costruiti in modo
che il tipo \texttt{long long} sia sufficiente.
Può però essere utile sapere che il compilatore \texttt{g++}
fornisce anche un tipo a 128 bit, \texttt{\_\_int128\_t},
il cui range è $-2^{127} \ldots 2^{127}-1$ o circa
$-10^{38} \ldots 10^{38}$.
Comunque questo tipo non è presente in tutti i sistemi di gara.

\subsubsection{Aritmetica modulare}

\index{resto}
\index{aritmetica modulare}

Il resto della divisione intera tra $x$ e $m$
viene indicato con $x \bmod m$.
Per esempio $17 \bmod 5 = 2$,
poichè $17 = 3 \cdot 5 + 2$.

A volte la risposta a un problema è un numero molto 
grande e quindi viene chiesto di dare in output
il numero ''modulo $m$'', cioè il resto
della risposta quando il numero grande è diviso per $m$
(per esempio ''modulo $10^9+7$'').
L'idea è che se anche la risposta "vera" è molto grande,
risulta sufficiente usare i tipi \texttt{int} e \texttt{long long}
per contenere il resto.

Una proprietà importante del modulo è che
nelle operazioni di addizione,
sottrazione e moltiplicazione, è possibile applicare il modulo
prima di eseguire l'operazione, cioè:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Quindi è possibile prendere il resto di ogni divisione
e in questo modo i numeri non diventeranno mai troppo grandi.

Per esempio, il seguente codice calcola $n!$,
il fattoriale di $n$, modulo $m$:

\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Normalmente si desidera che il resto sia
compreso tra $0\ldots m-1$.
Comunque, in C++ e in altri linguaggi,
il resto di un numero negativo può essere 0 
o un numero negativo. Per evitare questo problema
e assicurarsi di avere sempre a che fare con numeri 
positivi, si può prima calcolare il modulo e poi
aggiungere $m$ se il risultato è negativo:

\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}

La necessità di utilizzare questo genere di codice
si ha soltanto se sono presenti delle sottrazioni e
quindi il resto può diventare negativo.

\subsubsection{Numeri floating point}

\index{numeri floating point}

I tipi floating point utilizzati nelle gare
sono i \texttt{double} a 64 bit e, come estensione del
compilatore \texttt{g++}, i \texttt{long double} a 80 bit.
Nella maggior parte dei casi i \texttt{double} sono sufficienti,
ma i \texttt{long double} sono più precisi.

La precisione richiesta nella risposta è normalmente 
indicata nella descrizione del problema.
Il modo più semplice per stampare la risposta
è quello di usare la funzione \texttt{printf}
e scrivere il numero di cifre decimali nella stringa di formattazione.
Ad esempio il seguente codice stampa
il valore di $x$ con 9 cifre decimali:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Una difficoltà nell'utilizzo dei numeri floating point
è che alcuni numeri non possono essere rappresentati 
accuratamente utilizzando dei numeri floating point,
e quindi ci saranno degli errori di arrotondamento, come
si può vedere nel codice seguente, il cui risultato può sembrare 
sorprendente:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

A causa degli errori di arrotondamento,
il valore di $x$ è leggermente minore di 1,
dove il risultato corretto sarebbe proprio 1.

Confrontare numeri floating point utilizzando
l'operatore \texttt{==} può essere rischioso,
perchè sebbene i valori comparati dovrebbero teoricamente
essere uguali, magari non lo sono a causa di errori di arrotondamento.
Un modo migliore per comfrontare questo tipo di numeri
è quello di assumere che due numeri sono uguali se la differenza fra di loro 
è minore di un certo valore $\varepsilon$ piccolo a piacere.
In pratica il confronto viene fatto in questo modo, con $\varepsilon=10^{-9}$:

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a and b are equal
}
\end{lstlisting}

Da notare che nonostante i numeri floating point siano imprecisi,
gli interi fino a un certo valore possono comunque essere rappresentati accuratamente.
Per esempio, usando il tipo \texttt{double}, 
è possibile rappresentare accuratamente tutti gli interi il cui valore
assoluto sia minore o uguale a $2^{53}$.

\section{Scrivere codice conciso}

Nelle gare di programmazione è essenziale scrivere codice breve,
poichè i programmi dovrebbero essere scritti nel minor tempo possibile.
Per questo i programmatori usano spesso nomi brevi per
i tipi di dati e altre parti del codice.

\subsubsection{Abbreviare le dichiarazioni}
\index{tuppdef@\texttt{typedef}}
In C++ è possibile definire un nuovo nome più corto
a un tipo di dato già esistente
utilizzando la parola chiave \texttt{typedef}

Ad esempio, dato che il nome \texttt{long long} è lungo,
può essere ridefinito per brevità come \texttt{ll} nel seguente modo:

\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Dopo questa definizione, il codice:
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
potrà essere riscritto come:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

Il comando \texttt{typedef} può essere usato
anche per definire tipi di dati complessi.
Per esempio, il seguente codice assegna il nome \texttt{vi}
a un vettore di interi e il nome \texttt{pi} a un paio che contiene
una coppia di interi.

\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Macro}
\index{macro}
Un altro modo per scrivere codice più corto
è quello di definire delle \key{macro}.
Una macro indica che una certa stringa di codice
sarà sostituita con un'altra prima della compilazione.
In C++ le macro vengono definite usando la parola
chiave \texttt{\#define}.

Se ad esempio vengono definite queste macro:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
allora il codice:
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
potrà essere accorciato nel modo seguente:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Una macro può anche avere dei parametri, 
il che rende possibile la scrittura di loop
più corti e di altre strutture.
Definendo ad esempio la seguente macro:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
il codice:
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
risulterà così abbreviato:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

A volte le macro possono creare degli errori
difficili da individuare.
Si prenda ad esempio la macro che calcola 
il quadrato di un numero: 

\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Questa macro \emph{non} sempre si comporta come ci si aspetterebbe:
ad esempio il codice

\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corrisponde al codice
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Quella che segue è una versione corretta della stessa macro:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ora il codice
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corrisponderà al codice
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}


\section{Matematica}

La matematica gioca un ruolo importante 
nelle gare di programmazione e non è possibile 
diventare un ottenere dei buoni risultati
senza avere delle buone capacità matematiche.
In questa sezione verranno discussi alcuni 
importanti concetti matematiche e alcune formule 
che saranno necessarie nel proseguio del testo.

\subsubsection{Formule per le sommatorie}

Ogni somma della forma
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
dove $k$ è un intero positivo, ha una soluzione in forma chiusa
che è un polinomio di grado $k+1$.
Per esempio\footnote{\index{Faulhaber's formula}
C'è anche una formula generale per questo tipo di sommatorie, chiamata \key{formula di Faulhaber},
ma è troppo complessa per essere presentata qui,},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
e
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

Una \key{progressione aritmetica} è una \index{progressione aritmetica}
sequenza di numeri
dove la differenza tra due qualsiasi numeri consecutivi è costante.
Per esempio,
\[3, 7, 11, 15\]
è una progressione aritmetica con costante 4.
La somma di una progressione aritmetica può essere calcolata
usando la formula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{numbers}} = \frac{n(a+b)}{2}\]
dove $a$ è il primo numero,
$b$ è l'ultimo numero e 
$n$ è la quantità di numeri.
Per esempio
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
La formula è basata sul fatto che 
la somma consiste di $n$ numeri e il valore di
ogni elemento in media è $(a+b)/2$

\index{progressione geometrica}
Una \key{progressione geometrica} è una sequenza di numeri
dove il rapporto tra due qualsiasi termini consecutivi 
è costante.
Per esempio,
\[3,6,12,24\]
è una progressione geometrica con costante 2.
La somma si una progressione geometrica può essere calcolata
usando la seguente formula:
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
dove $a$ è il primo numero,
$b$ è l'ultimo numero e il rapporto
tra due numeri consecutivi è $k$.
Per esempio,

\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]

Questa formula si ottiene nel seguente modo. 
Sia
\[ S = a + ak + ak^2 + \cdots + b .\]
Moltiplicando entrambi i lati per $k$ si ottiene
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
e risolvendo l'equazione
\[ kS-S = bk-a\]
si arriva alla formula vista in precedenza.

Un caso speciale della somma di una progressione geometrica 
è la formula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{somma armonica}

Una \key{somma armonica} è una somma della forma
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

Il limite superiore di una somma armonica è $\log_2(n)+1$.
che si ottiene modificando ogni termine $1/k$  in modo che
$k$ diventi la più grande potenza del 2 che non sia maggiore di $k$.
Per esempio,se $n=6$, una stima della formula porta a: 
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Questo limite superiore consiste di $\log_2(n)+1$ parti
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, ecc.),
e il valore di ognuno di questi termini è al massimo 1.

\subsubsection{Teoria degli insiemi}

\index{teoria degli insiemi}
\index{insieme}
\index{intersezione}
\index{unione}
\index{differenza}
\index{sottoinsieme}
\index{insieme universale}
\index{complemento}

Un \key{insieme} (\key{set} in inglese) è una collezione di elementi.
Per esempio, l'insieme
\[X=\{2,4,7\}\]
contiene gli elementi 2, 4 e 7.
Il simbolo $\emptyset$ denota l'insieme vuoto,
e $|S|$ rappresenta la dimensione dell'insieme $S$,
cioè il numero di elementi dell'insieme.
Per esempio, nell'insieme definito prima,
$|X|=3$. 

Se un insieme $S$ contiene l'elemento $x$, 
allora si scrive $x \in S$, 
altrimenti si scrive $x \notin S$.
Sempre con riferimento all'insieme definito prima
\[4 \in X \hspace{10px}\textrm{and}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Nuovi insiemi possono essere definiti attraverso le seguenti operazioni:
\begin{itemize}
\item L'\key{intersezione} $A \cap B$ è formata dagli elementi
presenti sia in $A$ che in $B$.
Per esempio, se $A=\{1,2,5\}$ e $B=\{2,4\}$,
allora $A \cap B = \{2\}$.
\item L'\key{unione} $A \cup B$ è formata dagli elementi che
si trovano in $A$ o in $B$ o in entrambi.
Per esempio, se $A=\{3,7\}$ e $B=\{2,3,8\}$,
allora $A \cup B = \{2,3,7,8\}$.
\item L'\key{insieme complementare} di A, $\bar A$,  consiste degli elementi
che non sono in $A$.
L'interpretazione di cosa sia il complemento di un insieme dipende
dallla definizione che viene data all'\key{insieme universo}, che contiene tutti i possibili elementi.
Per esempio, se $A=\{1,2,5,7\}$ e l'insieme universo è
$\{1,2,\ldots,10\}$, allora $\bar A = \{3,4,6,8,9,10\}$.
\item La \key{differenza} $A \setminus B = A \cap \bar B$
è formata dagli elementi che appartengono ad $A$ ma non a $B$.
Va notato che $B$ può contenere elementi che non sono contenuti in $A$.
Per esempio, se $A=\{2,3,7,8\}$ e $B=\{3,5,8\}$,
allora $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

Se ogni elemento di $A$ appartiene anche a $S$,
si dice che $A$ è un \key{sottoinsieme} di $S$
e si scrive $A \subset S$.
Un insieme $S$ ha $2^{|S|}$ sottoinsiemi,
incluso l'insieme vuoto.
Per esempio, i sottoinsiemi dell'insieme $\{2,4,7\}$ sono
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ e $\{2,4,7\}$.
\end{center}

Gli insieme che vengono usati più frequentemente sono
$\mathbb{N}$ (numeri naturali),
$\mathbb{Z}$ (interi),
$\mathbb{Q}$ (numeri razionali) e
$\mathbb{R}$ (numeri reali).
L'insieme $\mathbb{N}$
può essere definito in due modi, a seconda del contesto:
o come $\mathbb{N}=\{0,1,2,\ldots\}$
oppure $\mathbb{N}=\{1,2,3,...\}$.

Un insieme può anche essere definito utilizzando una regola in questo modo: 
\[\{f(n) : n \in S\},\]
dove $f(n)$ è una qualche funzione.
Questo insieme contiene tutti gli elementi della forma $f(n)$,
dove $n$ è un elemento in $S$.
Per esempio l'insieme
\[X=\{2n : n \in \mathbb{Z}\}\]
contiene tutti gli interi pari.

\subsubsection{Logic}

\index{logic}
\index{negation}
\index{conjuction}
\index{disjunction}
\index{implication}
\index{equivalence}

The value of a logical expression is either
\key{true} (1) or \key{false} (0).
The most important logical operators are
$\lnot$ (\key{negation}),
$\land$ (\key{conjunction}),
$\lor$ (\key{disjunction}),
$\Rightarrow$ (\key{implication}) and
$\Leftrightarrow$ (\key{equivalence}).
The following table shows the meanings of these operators:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

The expression $\lnot A$ has the opposite value of $A$.
The expression $A \land B$ is true if both $A$ and $B$
are true,
and the expression $A \lor B$ is true if $A$ or $B$ or both
are true.
The expression $A \Rightarrow B$ is true
if whenever $A$ is true, also $B$ is true.
The expression $A \Leftrightarrow B$ is true
if $A$ and $B$ are both true or both false.

\index{predicate}

A \key{predicate} is an expression that is true or false
depending on its parameters.
Predicates are usually denoted by capital letters.
For example, we can define a predicate $P(x)$
that is true exactly when $x$ is a prime number.
Using this definition, $P(7)$ is true but $P(8)$ is false.

\index{quantifier}

A \key{quantifier} connects a logical expression
to the elements of a set.
The most important quantifiers are
$\forall$ (\key{for all}) and $\exists$ (\key{there is}).
For example,
\[\forall x (\exists y (y < x))\]
means that for each element $x$ in the set,
there is an element $y$ in the set
such that $y$ is smaller than $x$.
This is true in the set of integers,
but false in the set of natural numbers.

Using the notation described above,
we can express many kinds of logical propositions.
For example,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
means that if a number $x$ is larger than 1
and not a prime number,
then there are numbers $a$ and $b$
that are larger than $1$ and whose product is $x$.
This proposition is true in the set of integers.

\subsubsection{Functions}

The function $\lfloor x \rfloor$ rounds the number $x$
down to an integer, and the function
$\lceil x \rceil$ rounds the number $x$
up to an integer. For example,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{and} \hspace{10px} \lceil 3/2 \rceil = 2.\]

The functions $\min(x_1,x_2,\ldots,x_n)$
and $\max(x_1,x_2,\ldots,x_n)$
give the smallest and largest of values
$x_1,x_2,\ldots,x_n$.
For example,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{and} \hspace{10px} \max(1,2,3)=3.\]

\index{factorial}

The \key{factorial} $n!$ can be defined
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
or recursively
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{Fibonacci number}

The \key{Fibonacci numbers}
%\footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}
arise in many situations.
They can be defined recursively as follows:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
The first Fibonacci numbers are
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
There is also a closed-form formula
for calculating Fibonacci numbers, which is sometimes called
\index{Binet's formula} \key{Binet's formula}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logarithms}

\index{logarithm}

The \key{logarithm} of a number $x$
is denoted $\log_k(x)$, where $k$ is the base
of the logarithm.
According to the definition,
$\log_k(x)=a$ exactly when $k^a=x$.

A useful property of logarithms is
that $\log_k(x)$ equals the number of times
we have to divide $x$ by $k$ before we reach 
the number 1.
For example, $\log_2(32)=5$
because 5 divisions by 2 are needed:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Logarithms are often used in the analysis of
algorithms, because many efficient algorithms
halve something at each step.
Hence, we can estimate the efficiency of such algorithms
using logarithms.

The logarithm of a product is
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
and consequently,
\[\log_k(x^n) = n \cdot \log_k(x).\]
In addition, the logarithm of a quotient is
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Another useful formula is
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
and using this, it is possible to calculate
logarithms to any base if there is a way to
calculate logarithms to some fixed base.

\index{natural logarithm}

The \key{natural logarithm} $\ln(x)$ of a number $x$
is a logarithm whose base is $e \approx 2.71828$.
Another property of logarithms is that
the number of digits of an integer $x$ in base $b$ is
$\lfloor \log_b(x)+1 \rfloor$.
For example, the representation of
$123$ in base $2$ is 1111011 and
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Contests and resources}

\subsubsection{IOI}

The International Olympiad in Informatics (IOI)
is an annual programming contest for
secondary school students.
Each country is allowed to send a team of
four students to the contest.
There are usually about 300 participants
from 80 countries.

The IOI consists of two five-hour long contests.
In both contests, the participants are asked to
solve three algorithm tasks of various difficulty.
The tasks are divided into subtasks,
each of which has an assigned score.
Even if the contestants are divided into teams,
they compete as individuals.

The IOI syllabus \cite{iois} regulates the topics
that may appear in IOI tasks.
Almost all the topics in the IOI syllabus
are covered by this book.

Participants for the IOI are selected through
national contests.
Before the IOI, many regional contests are organized,
such as the Baltic Olympiad in Informatics (BOI),
the Central European Olympiad in Informatics (CEOI)
and the Asia-Pacific Informatics Olympiad (APIO).

Some countries organize online practice contests
for future IOI participants,
such as the Croatian Open Competition in Informatics \cite{coci}
and the USA Computing Olympiad \cite{usaco}.
In addition, a large collection of problems from Polish contests
is available online \cite{main}.

\subsubsection{ICPC}

The International Collegiate Programming Contest (ICPC)
is an annual programming contest for university students.
Each team in the contest consists of three students,
and unlike in the IOI, the students work together;
there is only one computer available for each team.

The ICPC consists of several stages, and finally the
best teams are invited to the World Finals.
While there are tens of thousands of participants
in the contest, there are only a small number\footnote{The exact number of final
slots varies from year to year; in 2017, there were 133 final slots.} of final slots available,
so even advancing to the finals
is a great achievement in some regions.

In each ICPC contest, the teams have five hours of time to
solve about ten algorithm problems.
A solution to a problem is accepted only if it solves
all test cases efficiently.
During the contest, competitors may view the results of other teams,
but for the last hour the scoreboard is frozen and it
is not possible to see the results of the last submissions.

The topics that may appear at the ICPC are not so well
specified as those at the IOI.
In any case, it is clear that more knowledge is needed
at the ICPC, especially more mathematical skills.

\subsubsection{Online contests}

There are also many online contests that are open for everybody.
At the moment, the most active contest site is Codeforces,
which organizes contests about weekly.
In Codeforces, participants are divided into two divisions:
beginners compete in Div2 and more experienced programmers in Div1.
Other contest sites include AtCoder, CS Academy, HackerRank and Topcoder.

Some companies organize online contests with onsite finals.
Examples of such contests are Facebook Hacker Cup,
Google Code Jam and Yandex.Algorithm.
Of course, companies also use those contests for recruiting:
performing well in a contest is a good way to prove one's skills.

\subsubsection{Books}

There are already some books (besides this book) that
focus on competitive programming and algorithmic problem solving:

\begin{itemize}
\item S. S. Skiena and M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

The first two books are intended for beginners,
whereas the last book contains advanced material.

Of course, general algorithm books are also suitable for
competitive programmers.
Some popular books are:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
